// Generated by CoffeeScript 1.10.0
(function() {
  var FS, FSU, IPC, Path, TSCompiler, options, ts;

  ts = require('typescript');

  FS = require('fs-extra');

  Path = require('path');

  FSU = require('../utils/fsu');

  IPC = require('../utils/ipc');

  options = {
    target: ts.ScriptTarget.ES5,
    module: ts.ModuleKind.CommonJS,
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    rootDir: '',
    outDir: '',
    sourceMap: true,
    emitBOM: false,
    experimentalDecorators: true,
    emitDecoratorMetadata: true,
    allowSyntheticDefaultImports: true,
    removeComments: false,
    noImplicitAny: false,
    noEmit: false,
    noEmitOnError: false,
    preserveConstEnums: true,
    suppressImplicitAnyIndexErrors: true
  };

  TSCompiler = (function() {
    function TSCompiler() {
      this.initialized = false;
      this.cfg = null;
      this.errors = null;
      this.files = {};
      this.paths = [];
      this.ipc = new IPC(process, this);
    }

    TSCompiler.prototype.init = function(cfg) {
      this.cfg = cfg;
      options.outDir = Path.join(this.cfg.base, this.cfg.tmp);
      options.rootDir = this.cfg.base;
      return null;
    };

    TSCompiler.prototype.addPath = function(path) {
      var file;
      file = this.files[path];
      if (!file) {
        this.paths.push(path);
        this.files[path] = {
          version: 0
        };
      } else {
        ++file.version;
      }
      return null;
    };

    TSCompiler.prototype.removePath = function(path) {
      if (this.files[path]) {
        this.paths.splice(this.paths.indexOf(path), 1);
        delete this.files[path];
      }
      return null;
    };

    TSCompiler.prototype.compile = function(files) {
      var allDiagnostics, emitResult, file, i, j, len, len1, path, program;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        path = file.path;
        if (!file.removed) {
          this.addPath(path);
        } else {
          this.removePath(path);
        }
      }
      if (!this.initialized) {
        this.errors = this.compileAll(this.paths, options);
      } else {
        if (!this.service) {
          this.createService();
        }
        this.errors = [];
        for (j = 0, len1 = files.length; j < len1; j++) {
          file = files[j];
          if (!file.removed) {
            this.compilePath(file.path);
          }
        }
        program = this.service.getProgram();
        emitResult = program.emit();
        allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
        allDiagnostics.forEach((function(_this) {
          return function(diagnostic) {
            var character, line, message, ref;
            ref = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = ref.line, character = ref.character;
            message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
            return _this.errors.push("  Error " + diagnostic.file.fileName + " (" + (line + 1) + ", " + (character + 1) + "): " + message);
          };
        })(this));
      }
      this.compiled();
      return null;
    };

    TSCompiler.prototype.compileAll = function(paths, options) {
      var allDiagnostics, emitResult, errors, program;
      program = ts.createProgram(paths, options);
      emitResult = program.emit();
      allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
      errors = [];
      allDiagnostics.forEach(function(diagnostic) {
        var character, line, message, ref;
        ref = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = ref.line, character = ref.character;
        message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
        return errors.push("  Error " + diagnostic.file.fileName + " (" + (line + 1) + ", " + (character + 1) + "): " + message);
      });
      return errors;
    };

    TSCompiler.prototype.compilePath = function(path) {
      var file, i, len, output, ref;
      if (/.d.ts/.test(path)) {
        return null;
      }
      output = this.service.getEmitOutput(path);
      ref = output.outputFiles;
      for (i = 0, len = ref.length; i < len; i++) {
        file = ref[i];
        FS.writeFileSync(file.name, file.text, "utf8");
      }
      return null;
    };

    TSCompiler.prototype.getErrors = function(path) {
      var allDiagnostics, errors;
      allDiagnostics = this.service.getCompilerOptionsDiagnostics().concat(this.service.getSyntacticDiagnostics(path)).concat(this.service.getSemanticDiagnostics(path));
      errors = [];
      allDiagnostics.forEach(function(diagnostic) {
        var character, line, message, ref;
        message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
        if (diagnostic.file) {
          ref = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = ref.line, character = ref.character;
          return errors.push("  Error " + diagnostic.file.fileName + " (" + (line + 1) + ", " + (character + 1) + "):  \r\n" + message);
        } else {
          return errors.push("  Error: " + message);
        }
      });
      return errors;
    };

    TSCompiler.prototype.createService = function() {
      this.servicesHost = {
        getScriptFileNames: (function(_this) {
          return function() {
            return _this.paths;
          };
        })(this),
        getScriptVersion: (function(_this) {
          return function(path) {
            return _this.files[path] && _this.files[path].version.toString();
          };
        })(this),
        getScriptSnapshot: function(path) {
          if (!FSU.isFile(path)) {
            return void 0;
          }
          return ts.ScriptSnapshot.fromString(FS.readFileSync(path).toString());
        },
        getCurrentDirectory: function() {
          return process.cwd();
        },
        getCompilationSettings: function() {
          return options;
        },
        getDefaultLibFileName: function(options) {
          return ts.getDefaultLibFilePath(options);
        }
      };
      this.service = ts.createLanguageService(this.servicesHost, ts.createDocumentRegistry());
      return null;
    };

    TSCompiler.prototype.compiled = function() {
      this.initialized = true;
      return this.ipc.send('compiled', 'ts', this.errors);
    };

    return TSCompiler;

  })();

  module.exports = new TSCompiler();

}).call(this);

//# sourceMappingURL=ts.js.map
