// Generated by CoffeeScript 1.10.0
(function() {
  var IPC, Path, SassWorker, Spawn, _, instance, options;

  Path = require('path');

  _ = require('lodash');

  Spawn = require('cross-spawn');

  IPC = require('../utils/ipc');

  options = {
    'style': 'nested',
    'stop-on-error': false,
    'sourcemap': 'auto',
    'default-encoding': 'utf-8',
    'check': true,
    'precision': 5,
    'cache-location': '',
    'quiet': false
  };

  SassWorker = (function() {
    function SassWorker() {
      this.initialized = false;
      this.cfg = null;
      this.errors = null;
      this.ipc = new IPC(process, this);
    }

    SassWorker.prototype.init = function(cfg) {
      this.cfg = cfg;
      options['cache-location'] = Path.join(this.cfg.base, this.cfg.tmp, '.sass-cache');
      return null;
    };

    SassWorker.prototype.compile = function(files) {
      var args, sass;
      this.t = Date.now();
      this.errors = [];
      args = this.createCmdArgs(files);
      sass = Spawn('sass', args);
      sass.on('error', (function(_this) {
        return function(error) {
          console.log('sass ERROR: ', error);
          _this.compiled();
          return null;
        };
      })(this));
      sass.on('close', (function(_this) {
        return function(code) {
          console.log('sass.close: ', code);
          _this.compiled();
          return null;
        };
      })(this));
      sass.stdout.on('data', (function(_this) {
        return function(data) {
          var error, i, len, line;
          console.log('sass.onData: ', data.toString());
          data = data.toString().split(/\\r\\n|\\n/);
          for (i = 0, len = data.length; i < len; i++) {
            line = data[i];
            error = _this.getError(line);
            if (error) {
              _this.errors.push(error);
            }
          }
          return null;
        };
      })(this));
      sass.stderr.on('data', (function(_this) {
        return function(data) {
          console.log('sass ERR.DATA: ', data.toString());
          return null;
        };
      })(this));
      return null;
    };

    SassWorker.prototype.createCmdArgs = function(files) {
      var args, base, file, i, key, len, out, path, tmp, value;
      args = [];
      for (key in options) {
        value = options[key];
        if (key === 'update') {
          null;
        } else if (_.isBoolean(value)) {
          if (value) {
            args.push('--' + key);
          }
        } else {
          if (key === 'sourcemap') {
            args.push('--' + key + '=' + value);
          } else {
            args.push('--' + key);
            args.push(value);
          }
        }
      }
      if (this.initialized) {
        args.push('--update');
      }
      base = this.cfg.base;
      tmp = this.cfg.tmp;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        path = file.path;
        if (!/^_/.test(Path.basename(path))) {
          out = Path.join(base, tmp, Path.relative(base, path));
          out = out.replace(/\.sass$|\.scss$/, '.css');
          args.push(path + ':' + out);
        }
      }
      return args;
    };

    SassWorker.prototype.getError = function(data) {
      var end, error, path;
      if (!/^      error /.test(data)) {
        return null;
      }
      data = data.substr(12);
      end = data.indexOf(' (Line');
      path = data.substr(0, end);
      error = data.substr(end);
      return {
        path: path,
        error: error
      };
    };

    SassWorker.prototype.compiled = function() {
      this.initialized = true;
      return this.ipc.send('compiled', 'sass', this.errors);
    };

    return SassWorker;

  })();

  instance = new SassWorker();

}).call(this);

//# sourceMappingURL=_sass.js.map
