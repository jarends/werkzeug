// Generated by CoffeeScript 1.10.0
(function() {
  var EMap, Emitter, IPC, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Emitter = require('events');

  EMap = require('emap');

  _ = require('../utils/pimped-lodash');

  IPC = (function(superClass) {
    extend(IPC, superClass);

    IPC.isChild = function() {
      return process.send && !module.parent;
    };

    function IPC(process, owner) {
      this.owner = owner;
      this.emap = new EMap();
      if (process) {
        this.init(process, this.owner);
      }
    }

    IPC.prototype.init = function(process, owner) {
      this.owner = owner;
      if (this.process) {
        this.emap.all();
      }
      this.process = process;
      this.emap.map(process, 'message', this.messageHandler, this);
      this.emap.map(process, 'close', this.closeHandler, this);
      this.emap.map(process, 'disconnect', this.disconnectHandler, this);
      this.emap.map(process, 'error', this.errorHandler, this);
      this.emap.map(process, 'exit', this.exitHandler, this);
      return null;
    };

    IPC.prototype.send = function() {
      var args, type;
      type = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!this.process || !this.process.connected) {
        return null;
      }
      this.process.send({
        type: type,
        args: args
      });
      return null;
    };

    IPC.prototype.exit = function() {
      if (this.process) {
        return this.process.kill();
      }
    };

    IPC.prototype.messageHandler = function(message) {
      var args, e, error, type;
      type = message != null ? message.type : void 0;
      if (!type) {
        return null;
      }
      args = message.args || [];
      if (!_.isArray(args)) {
        return null;
      }
      if (this.owner && _.isFunction(this.owner[type])) {
        try {
          this.owner[type].apply(this.owner, args);
        } catch (error) {
          e = error;
          console.log("IPC ERROR: can not handle type '" + type + "' for owner '" + this.owner + "': ", e);
        }
      }
      if (this.listenerCount(type)) {
        args = args.concat();
        args.unshift(type);
        this.emit.apply(this, args);
      }
      return null;
    };

    IPC.prototype.closeHandler = function() {
      return null;
    };

    IPC.prototype.disconnectHandler = function() {
      return null;
    };

    IPC.prototype.errorHandler = function() {
      return null;
    };

    IPC.prototype.exitHandler = function() {
      return null;
    };

    return IPC;

  })(Emitter);

  module.exports = IPC;

}).call(this);
