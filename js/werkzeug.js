// Generated by CoffeeScript 1.10.0
(function() {
  var Builder, Colors, Compiler, Config, Emitter, FS, FSU, Packer, Path, Paths, SW, Server, WZ, Walker, Watcher, Werkzeug,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Emitter = require('events');

  FS = require('fs');

  Path = require('path');

  Colors = require('colors');

  Config = require('./config');

  Paths = require('./utils/paths');

  Server = require('./server');

  Walker = require('./walker');

  Watcher = require('./watcher');

  Compiler = require('./compiler');

  Packer = require('./packer');

  Builder = require('./builder');

  FSU = require('./utils/fsu');

  SW = require('./utils/stopwatch');


  /*
      black
      red
      green
      yellow
      blue
      magenta
      cyan
      white
      gray
      grey
   */

  Colors.setTheme({
    error: 'red'
  });

  Werkzeug = (function(superClass) {
    extend(Werkzeug, superClass);

    Werkzeug.ignores = 'node_modules$|\\.DS_Store$|dist$|\\.idea$|\\.git$|gulpfile\\.coffee$|Gruntfile\\.coffee$|\\.wz\\.tmp$';

    Werkzeug.interests = '\\.coffee$|\\.ts$|\\.sass$|\\.scss$|\\.less$';

    Werkzeug.updateDelay = 500;

    function Werkzeug(base) {
      this.terminate = bind(this.terminate, this);
      this.updateNow = bind(this.updateNow, this);
      var tmp;
      Werkzeug.__super__.constructor.apply(this, arguments);
      console.log('werkzeug starting...'.cyan);
      SW.start('wz.startup');
      this.cfg = new Config(base);
      this.paths = new Paths(this.cfg);
      this.server = new Server(this);
      this.walker = new Walker(this);
      this.watcher = new Watcher(this);
      this.compiler = new Compiler(this);
      this.packer = new Packer(this);
      this.builder = new Builder(this);
      this.ignores = new RegExp("(" + WZ.ignores + ")");
      this.interests = new RegExp("(" + WZ.interests + ")");
      this.errors = [];
      this.files = [];
      this.fileMap = {};
      this.idle = true;
      this.initialized = false;
      this.dirty = false;
      tmp = Path.join(this.cfg.base, this.cfg.tmp);
      if (FSU.isDir(tmp)) {
        FSU.rmDir(tmp);
      }
      FS.mkdirSync(tmp);
      process.on('exit', this.terminate);
      process.on('SIGINT', this.terminate);
      process.on('SIGTERM', this.terminate);
    }

    Werkzeug.prototype.watch = function() {
      if (!this.idle || this.watcher.watching) {
        return;
      }
      this.server.init();
      this.watcher.watch();
      return null;
    };

    Werkzeug.prototype.walk = function() {
      if (!this.idle) {
        return;
      }
      this.idle = false;
      this.walker.walk();
      return null;
    };

    Werkzeug.prototype.walked = function() {
      this.idle = true;
      this.compile();
      return null;
    };

    Werkzeug.prototype.compile = function() {
      if (!this.idle) {
        return;
      }
      this.idle = false;
      SW.start('wz.update');
      this.compiler.compile();
      this.cleanFiles();
      this.dirty = false;
      return null;
    };

    Werkzeug.prototype.compiled = function() {
      this.idle = true;
      this.pack();
      return null;
    };

    Werkzeug.prototype.pack = function() {
      if (!this.idle) {
        return;
      }
      this.idle = false;
      this.packer.pack(this.compiler.files);
      return null;
    };

    Werkzeug.prototype.packed = function() {
      this.idle = true;
      if (!this.initialized) {
        this.initialized = true;
        if (this.watcher.watching) {
          console.log(("werkzeug startup in " + (SW.stop('wz.startup')) + "ms").cyan);
        } else {
          console.log(("werkzeug single run in " + (SW.stop('wz.startup')) + "ms").cyan);
        }
      } else if (this.compiler.files && this.compiler.files.length) {
        console.log(("werkzeug update in " + (SW.stop('wz.update')) + "ms").cyan);
      }
      if (this.watcher.watching) {
        if (this.dirty) {
          this.update();
        } else if (this.compiler.files && this.compiler.files.length) {
          console.log('start watching ...'.cyan);
        }
      } else {
        this.terminate();
      }
      return null;
    };

    Werkzeug.prototype.update = function() {
      this.dirty = true;
      if (!this.idle || !this.initialized) {
        return;
      }
      clearTimeout(this.updateTimeout);
      this.updateTimeout = setTimeout(this.updateNow, WZ.updateDelay);
      return null;
    };

    Werkzeug.prototype.updateNow = function() {
      if (!this.idle) {
        return;
      }
      this.compile();
      return null;
    };

    Werkzeug.prototype.cleanFiles = function() {
      var file, index, path, ref;
      this.errors = [];
      ref = this.fileMap;
      for (path in ref) {
        file = ref[path];
        if (file.dirty) {
          if (file.removed) {
            index = this.files.indexOf(file);
            if (index > -1) {
              this.files.splice(index, 1);
            }
            delete this.fileMap[file.path];
          } else {
            file.dirty = false;
            file.added = false;
            file.changed = false;
            file.errors = null;
          }
        }
      }
      return null;
    };

    Werkzeug.prototype.fileAdded = function(path) {
      var file;
      file = this.fileMap[path];
      if (file) {
        file.removed = false;
      } else {
        this.files.push(file = this.fileMap[path] = {});
      }
      file.path = path;
      file.added = Date.now();
      file.dirty = true;
      file.errors = null;
      this.update();
      return null;
    };

    Werkzeug.prototype.fileChanged = function(path) {
      var file;
      file = this.fileMap[path];
      if (!file) {
        return;
      }
      file.changed = Date.now();
      file.dirty = true;
      file.errors = null;
      this.update();
      return null;
    };

    Werkzeug.prototype.fileRemoved = function(path) {
      var file;
      file = this.fileMap[path];
      if (!file) {
        return;
      }
      file.removed = Date.now();
      file.dirty = true;
      this.update();
      return null;
    };

    Werkzeug.prototype.getIn = function(type, path) {
      return this.paths.getIn(type, path);
    };

    Werkzeug.prototype.getOut = function(type, path) {
      return this.paths.getOut(type, path);
    };

    Werkzeug.prototype.ignore = function(path) {
      return this.ignores.test(path);
    };

    Werkzeug.prototype.interested = function(path) {
      return this.interests.test(path);
    };

    Werkzeug.prototype.terminate = function() {
      console.log('\rterminate');
      clearTimeout(this.updateTimeout);
      this.compiler.exit();
      this.packer.exit();
      this.server.exit();
      process.removeAllListeners();
      setTimeout(function() {
        return process.exit(0);
      });
      return null;
    };

    return Werkzeug;

  })(Emitter);

  module.exports = WZ = Werkzeug;

}).call(this);
