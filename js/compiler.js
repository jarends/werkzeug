// Generated by CoffeeScript 1.10.0
(function() {
  var ASSETW, CP, Compiler, IPC, Path, Reg, SASSW, SW, TSW;

  Path = require('path');

  CP = require('child_process');

  IPC = require('./utils/ipc');

  Reg = require('./utils/regex');

  SW = require('./utils/stopwatch');

  TSW = Path.join(__dirname, 'compiler', 'ts');

  ASSETW = Path.join(__dirname, 'compiler', 'assets');

  SASSW = Path.join(__dirname, 'compiler', 'sass');

  Compiler = (function() {
    function Compiler(wz) {
      this.wz = wz;
      this.cfg = this.wz.cfg;
      this.ts = {
        ipc: new IPC(CP.fork(TSW), this),
        compiled: false
      };
      this.sass = {
        ipc: new IPC(CP.fork(SASSW), this),
        compiled: false
      };
      this.assets = {
        ipc: new IPC(CP.fork(ASSETW), this),
        compiled: false
      };
      this.ts.ipc.send('init', this.cfg);
      this.sass.ipc.send('init', this.cfg);
      this.assets.ipc.send('init', this.cfg);
    }

    Compiler.prototype.compile = function() {
      var assets, current, file, i, len, path, ref, removed, root, sass, ts, used;
      console.log("compile " + this.wz.files.length + " files");
      current = [];
      ts = [];
      sass = [];
      assets = [];
      root = Path.join(this.cfg.base, this.cfg.root);
      this.ts.compiled = false;
      this.sass.compiled = false;
      this.assets.compiled = false;
      SW.start('ts');
      SW.start('sass');
      SW.start('assets');
      SW.start('total');
      ref = this.wz.files;
      for (i = 0, len = ref.length; i < len; i++) {
        file = ref[i];
        if (file.dirty) {
          path = file.path;
          removed = file.removed;
          used = false;
          if (Reg.testTS(path)) {
            ts.push(file);
            used = true;
          } else if (Reg.testSass(path) && !removed) {
            sass.push(file);
            used = true;
          } else if (path.indexOf(root) === 0 && !removed) {
            assets.push(file);
            used = true;
          }
          if (removed) {
            assets.push(file);
            used = true;
          }
          if (used) {
            current.push({
              path: file.path,
              removed: file.removed
            });
          }
        }
      }
      if (assets.length) {
        this.assets.ipc.send('compile', assets);
      } else {
        this.assets.compiled = true;
      }
      if (sass.length) {
        this.sass.ipc.send('compile', sass);
      } else {
        this.sass.compiled = true;
      }
      if (ts.length) {
        this.ts.ipc.send('compile', ts);
      } else {
        this.ts.compiled = true;
      }
      return current;
    };

    Compiler.prototype.compiled = function(comp, errors) {
      console.log(comp + " compiled in " + (SW.stop(comp)) + "ms " + (errors && errors.length ? 'with ' + errors.length + ' errors' : 'without errors'), errors);
      this[comp].compiled = true;
      if (this.ts.compiled && this.sass.compiled && this.assets.compiled) {
        console.log("total compile time: " + (SW.stop('total')) + "ms ");
        this.wz.compiled();
      }
      return null;
    };

    Compiler.prototype.exit = function() {
      this.ts.ipc.exit();
      this.sass.ipc.exit();
      this.assets.ipc.exit();
      return null;
    };

    return Compiler;

  })();

  module.exports = Compiler;

}).call(this);

//# sourceMappingURL=compiler.js.map
